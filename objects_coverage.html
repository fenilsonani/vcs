
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>objects: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/fenilsonani/vcs/internal/core/objects/blob.go (92.9%)</option>
				
				<option value="file1">github.com/fenilsonani/vcs/internal/core/objects/commit.go (95.6%)</option>
				
				<option value="file2">github.com/fenilsonani/vcs/internal/core/objects/hash.go (100.0%)</option>
				
				<option value="file3">github.com/fenilsonani/vcs/internal/core/objects/storage.go (53.5%)</option>
				
				<option value="file4">github.com/fenilsonani/vcs/internal/core/objects/tag.go (96.6%)</option>
				
				<option value="file5">github.com/fenilsonani/vcs/internal/core/objects/tree.go (98.0%)</option>
				
				<option value="file6">github.com/fenilsonani/vcs/internal/core/objects/types.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package objects

import (
        "bytes"
        "io"
)

// Blob represents a git blob object (file content)
type Blob struct {
        id   ObjectID
        data []byte
}

// NewBlob creates a new blob object from data
func NewBlob(data []byte) *Blob <span class="cov8" title="1">{
        b := &amp;Blob{
                data: data,
        }
        b.id = ComputeHash(TypeBlob, data)
        return b
}</span>

// NewBlobFromReader creates a new blob object from a reader
func NewBlobFromReader(r io.Reader) (*Blob, error) <span class="cov8" title="1">{
        data, err := io.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return NewBlob(data), nil</span>
}

// Type returns the object type
func (b *Blob) Type() ObjectType <span class="cov8" title="1">{
        return TypeBlob
}</span>

// Size returns the size of the blob data
func (b *Blob) Size() int64 <span class="cov8" title="1">{
        return int64(len(b.data))
}</span>

// ID returns the object ID
func (b *Blob) ID() ObjectID <span class="cov8" title="1">{
        return b.id
}</span>

// Data returns the blob data
func (b *Blob) Data() []byte <span class="cov8" title="1">{
        return b.data
}</span>

// Reader returns a reader for the blob data
func (b *Blob) Reader() io.Reader <span class="cov8" title="1">{
        return bytes.NewReader(b.data)
}</span>

// Serialize returns the raw blob data
func (b *Blob) Serialize() ([]byte, error) <span class="cov8" title="1">{
        return b.data, nil
}</span>

// ParseBlob parses a blob from raw object data
func ParseBlob(id ObjectID, data []byte) *Blob <span class="cov8" title="1">{
        return &amp;Blob{
                id:   id,
                data: data,
        }
}</pre>
		
		<pre class="file" id="file1" style="display: none">package objects

import (
        "bufio"
        "bytes"
        "fmt"
        "strings"
        "time"
)

// Commit represents a git commit object
type Commit struct {
        id        ObjectID
        tree      ObjectID
        parents   []ObjectID
        author    Signature
        committer Signature
        message   string
}

// NewCommit creates a new commit object
func NewCommit(tree ObjectID, parents []ObjectID, author, committer Signature, message string) *Commit <span class="cov8" title="1">{
        c := &amp;Commit{
                tree:      tree,
                parents:   parents,
                author:    author,
                committer: committer,
                message:   message,
        }
        c.computeID()
        return c
}</span>

// Type returns the object type
func (c *Commit) Type() ObjectType <span class="cov8" title="1">{
        return TypeCommit
}</span>

// Size returns the serialized size
func (c *Commit) Size() int64 <span class="cov8" title="1">{
        data, _ := c.Serialize()
        return int64(len(data))
}</span>

// ID returns the object ID
func (c *Commit) ID() ObjectID <span class="cov8" title="1">{
        if c.id.IsZero() </span><span class="cov0" title="0">{
                c.computeID()
        }</span>
        <span class="cov8" title="1">return c.id</span>
}

// Tree returns the tree object ID
func (c *Commit) Tree() ObjectID <span class="cov8" title="1">{
        return c.tree
}</span>

// Parents returns the parent commit IDs
func (c *Commit) Parents() []ObjectID <span class="cov8" title="1">{
        return c.parents
}</span>

// Author returns the author signature
func (c *Commit) Author() Signature <span class="cov8" title="1">{
        return c.author
}</span>

// Committer returns the committer signature
func (c *Commit) Committer() Signature <span class="cov8" title="1">{
        return c.committer
}</span>

// Message returns the commit message
func (c *Commit) Message() string <span class="cov8" title="1">{
        return c.message
}</span>

// Serialize serializes the commit object
func (c *Commit) Serialize() ([]byte, error) <span class="cov8" title="1">{
        var buf bytes.Buffer
        
        // Tree
        fmt.Fprintf(&amp;buf, "tree %s\n", c.tree)
        
        // Parents
        for _, parent := range c.parents </span><span class="cov8" title="1">{
                fmt.Fprintf(&amp;buf, "parent %s\n", parent)
        }</span>
        
        // Author
        <span class="cov8" title="1">fmt.Fprintf(&amp;buf, "author %s\n", c.author)
        
        // Committer
        fmt.Fprintf(&amp;buf, "committer %s\n", c.committer)
        
        // Empty line before message
        buf.WriteByte('\n')
        
        // Message
        buf.WriteString(c.message)
        
        return buf.Bytes(), nil</span>
}

// computeID calculates the commit's object ID
func (c *Commit) computeID() <span class="cov8" title="1">{
        data, _ := c.Serialize()
        c.id = ComputeHash(TypeCommit, data)
}</span>

// ParseCommit parses a commit from raw object data
func ParseCommit(id ObjectID, data []byte) (*Commit, error) <span class="cov8" title="1">{
        commit := &amp;Commit{
                id:      id,
                parents: make([]ObjectID, 0),
        }
        
        scanner := bufio.NewScanner(bytes.NewReader(data))
        
        // Parse headers
        inHeaders := true
        var messageLines []string
        
        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                
                if inHeaders </span><span class="cov8" title="1">{
                        if line == "" </span><span class="cov8" title="1">{
                                inHeaders = false
                                continue</span>
                        }
                        
                        <span class="cov8" title="1">parts := strings.SplitN(line, " ", 2)
                        if len(parts) != 2 </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("invalid commit header: %s", line)
                        }</span>
                        
                        <span class="cov8" title="1">key, value := parts[0], parts[1]
                        
                        switch key </span>{
                        case "tree":<span class="cov8" title="1">
                                tree, err := NewObjectID(value)
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("invalid tree ID: %w", err)
                                }</span>
                                <span class="cov8" title="1">commit.tree = tree</span>
                                
                        case "parent":<span class="cov8" title="1">
                                parent, err := NewObjectID(value)
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("invalid parent ID: %w", err)
                                }</span>
                                <span class="cov8" title="1">commit.parents = append(commit.parents, parent)</span>
                                
                        case "author":<span class="cov8" title="1">
                                sig, err := parseSignatureLine(value)
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("invalid author: %w", err)
                                }</span>
                                <span class="cov8" title="1">commit.author = *sig</span>
                                
                        case "committer":<span class="cov8" title="1">
                                sig, err := parseSignatureLine(value)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("invalid committer: %w", err)
                                }</span>
                                <span class="cov8" title="1">commit.committer = *sig</span>
                                
                        default:<span class="cov0" title="0"></span>
                                // Ignore unknown headers
                        }
                } else<span class="cov8" title="1"> {
                        messageLines = append(messageLines, line)
                }</span>
        }
        
        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing commit: %w", err)
        }</span>
        
        <span class="cov8" title="1">commit.message = strings.Join(messageLines, "\n")
        if len(messageLines) &gt; 0 &amp;&amp; !strings.HasSuffix(commit.message, "\n") </span><span class="cov8" title="1">{
                commit.message += "\n"
        }</span>
        
        <span class="cov8" title="1">return commit, nil</span>
}

// parseSignatureLine parses a signature from a line like "Name &lt;email&gt; timestamp timezone"
func parseSignatureLine(line string) (*Signature, error) <span class="cov8" title="1">{
        // Find email boundaries
        emailStart := strings.IndexByte(line, '&lt;')
        emailEnd := strings.IndexByte(line, '&gt;')
        
        if emailStart == -1 || emailEnd == -1 || emailStart &gt;= emailEnd </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid signature format")
        }</span>
        
        <span class="cov8" title="1">name := strings.TrimSpace(line[:emailStart])
        email := line[emailStart+1 : emailEnd]
        
        // Parse timestamp and timezone
        timeStr := strings.TrimSpace(line[emailEnd+1:])
        parts := strings.Fields(timeStr)
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid timestamp format")
        }</span>
        
        <span class="cov8" title="1">timestamp, err := parseUnixTimestamp(parts[0], parts[1])
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">return &amp;Signature{
                Name:  name,
                Email: email,
                When:  timestamp,
        }, nil</span>
}

// parseUnixTimestamp parses a unix timestamp with timezone
func parseUnixTimestamp(unixStr, tzStr string) (time.Time, error) <span class="cov8" title="1">{
        var unix int64
        n, err := fmt.Sscanf(unixStr, "%d", &amp;unix)
        if err != nil || n != 1 </span><span class="cov8" title="1">{
                return time.Time{}, fmt.Errorf("invalid timestamp")
        }</span>
        
        // Parse timezone offset (e.g., "+0200" or "-0700")
        <span class="cov8" title="1">var tzOffset int
        n, err = fmt.Sscanf(tzStr, "%d", &amp;tzOffset)
        if err != nil || n != 1 </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("invalid timezone")
        }</span>
        
        // Convert timezone offset to seconds
        <span class="cov8" title="1">hours := tzOffset / 100
        minutes := tzOffset % 100
        offsetSeconds := hours*3600 + minutes*60
        
        // Create location with the offset
        location := time.FixedZone("", offsetSeconds)
        
        return time.Unix(unix, 0).In(location), nil</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package objects

import (
        "crypto/sha1"
        "encoding/hex"
        "fmt"
        "io"
)

// ObjectID represents a SHA-1 hash used to identify git objects
type ObjectID [20]byte

// String returns the hexadecimal string representation of the ObjectID
func (id ObjectID) String() string <span class="cov8" title="1">{
        return hex.EncodeToString(id[:])
}</span>

// Short returns the first 7 characters of the hash
func (id ObjectID) Short() string <span class="cov8" title="1">{
        return id.String()[:7]
}</span>

// IsZero returns true if the ObjectID is all zeros
func (id ObjectID) IsZero() bool <span class="cov8" title="1">{
        for _, b := range id </span><span class="cov8" title="1">{
                if b != 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Equal returns true if two ObjectIDs are equal
func (id ObjectID) Equal(other ObjectID) bool <span class="cov8" title="1">{
        return id == other
}</span>

// NewObjectID creates an ObjectID from a hexadecimal string
func NewObjectID(hexStr string) (ObjectID, error) <span class="cov8" title="1">{
        var id ObjectID
        
        if len(hexStr) != 40 </span><span class="cov8" title="1">{
                return id, fmt.Errorf("invalid object ID length: expected 40, got %d", len(hexStr))
        }</span>
        
        <span class="cov8" title="1">bytes, err := hex.DecodeString(hexStr)
        if err != nil </span><span class="cov8" title="1">{
                return id, fmt.Errorf("invalid hex string: %w", err)
        }</span>
        
        <span class="cov8" title="1">copy(id[:], bytes)
        return id, nil</span>
}

// ComputeHash calculates the SHA-1 hash of the given data with the object type prefix
func ComputeHash(objectType ObjectType, data []byte) ObjectID <span class="cov8" title="1">{
        h := sha1.New()
        fmt.Fprintf(h, "%s %d\x00", objectType, len(data))
        h.Write(data)
        
        var id ObjectID
        copy(id[:], h.Sum(nil))
        return id
}</span>

// HashReader calculates the SHA-1 hash while reading from an io.Reader
func HashReader(objectType ObjectType, size int64, r io.Reader) (ObjectID, error) <span class="cov8" title="1">{
        h := sha1.New()
        fmt.Fprintf(h, "%s %d\x00", objectType, size)
        
        if _, err := io.Copy(h, r); err != nil </span><span class="cov8" title="1">{
                return ObjectID{}, fmt.Errorf("failed to hash reader: %w", err)
        }</span>
        
        <span class="cov8" title="1">var id ObjectID
        copy(id[:], h.Sum(nil))
        return id, nil</span>
}

// ParseObjectID attempts to parse an ObjectID from various formats
func ParseObjectID(input string) (ObjectID, error) <span class="cov8" title="1">{
        // Remove any whitespace
        input = trimWhitespace(input)
        
        // Handle full 40-character hash
        if len(input) == 40 </span><span class="cov8" title="1">{
                return NewObjectID(input)
        }</span>
        
        // For abbreviated hashes, we would need access to the object database
        // This is a placeholder for now
        <span class="cov8" title="1">return ObjectID{}, fmt.Errorf("abbreviated object IDs not yet supported: %s", input)</span>
}

func trimWhitespace(s string) string <span class="cov8" title="1">{
        // Fast whitespace trimming
        start := 0
        end := len(s)
        
        for start &lt; end &amp;&amp; isWhitespace(s[start]) </span><span class="cov8" title="1">{
                start++
        }</span>
        
        <span class="cov8" title="1">for end &gt; start &amp;&amp; isWhitespace(s[end-1]) </span><span class="cov8" title="1">{
                end--
        }</span>
        
        <span class="cov8" title="1">return s[start:end]</span>
}

func isWhitespace(b byte) bool <span class="cov8" title="1">{
        return b == ' ' || b == '\t' || b == '\n' || b == '\r'
}</pre>
		
		<pre class="file" id="file3" style="display: none">package objects

import (
        "bytes"
        "compress/zlib"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sync"
)

// Storage handles reading and writing git objects
type Storage struct {
        basePath string
        mu       sync.RWMutex
        cache    map[ObjectID]Object // Simple in-memory cache
}

// NewStorage creates a new object storage
func NewStorage(gitDir string) *Storage <span class="cov8" title="1">{
        return &amp;Storage{
                basePath: filepath.Join(gitDir, "objects"),
                cache:    make(map[ObjectID]Object),
        }
}</span>

// Init initializes the object storage directory structure
func (s *Storage) Init() error <span class="cov8" title="1">{
        // Create objects directory
        if err := os.MkdirAll(s.basePath, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create objects directory: %w", err)
        }</span>
        
        // Create subdirectories for loose objects (00-ff)
        <span class="cov8" title="1">for i := 0; i &lt; 256; i++ </span><span class="cov8" title="1">{
                dir := filepath.Join(s.basePath, fmt.Sprintf("%02x", i))
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create object subdirectory: %w", err)
                }</span>
        }
        
        // Create pack directory
        <span class="cov8" title="1">packDir := filepath.Join(s.basePath, "pack")
        if err := os.MkdirAll(packDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create pack directory: %w", err)
        }</span>
        
        // Create info directory
        <span class="cov8" title="1">infoDir := filepath.Join(s.basePath, "info")
        if err := os.MkdirAll(infoDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create info directory: %w", err)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// WriteObject writes an object to storage
func (s *Storage) WriteObject(obj Object) error <span class="cov8" title="1">{
        id := obj.ID()
        
        // Check if object already exists
        if s.HasObject(id) </span><span class="cov8" title="1">{
                return nil
        }</span>
        
        // Serialize object
        <span class="cov8" title="1">data, err := obj.Serialize()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to serialize object: %w", err)
        }</span>
        
        // Create object header
        <span class="cov8" title="1">header := fmt.Sprintf("%s %d\x00", obj.Type(), len(data))
        fullData := append([]byte(header), data...)
        
        // Compress data
        compressed, err := compressData(fullData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to compress object: %w", err)
        }</span>
        
        // Write to loose object file
        <span class="cov8" title="1">path := s.objectPath(id)
        dir := filepath.Dir(path)
        
        // Ensure directory exists
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create object directory: %w", err)
        }</span>
        
        // Write atomically using a temporary file
        <span class="cov8" title="1">tmpPath := path + ".tmp"
        if err := os.WriteFile(tmpPath, compressed, 0444); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write object file: %w", err)
        }</span>
        
        // Rename to final location
        <span class="cov8" title="1">if err := os.Rename(tmpPath, path); err != nil </span><span class="cov0" title="0">{
                os.Remove(tmpPath)
                return fmt.Errorf("failed to finalize object file: %w", err)
        }</span>
        
        // Update cache
        <span class="cov8" title="1">s.mu.Lock()
        s.cache[id] = obj
        s.mu.Unlock()
        
        return nil</span>
}

// ReadObject reads an object from storage
func (s *Storage) ReadObject(id ObjectID) (Object, error) <span class="cov8" title="1">{
        // Check cache first
        s.mu.RLock()
        if obj, ok := s.cache[id]; ok </span><span class="cov8" title="1">{
                s.mu.RUnlock()
                return obj, nil
        }</span>
        <span class="cov8" title="1">s.mu.RUnlock()
        
        // Read from loose object
        path := s.objectPath(id)
        compressed, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        // TODO: Check packfiles
                        return nil, fmt.Errorf("object not found: %s", id)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to read object file: %w", err)</span>
        }
        
        // Decompress data
        <span class="cov0" title="0">fullData, err := decompressData(compressed)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decompress object: %w", err)
        }</span>
        
        // Parse header
        <span class="cov0" title="0">nullIdx := bytes.IndexByte(fullData, 0)
        if nullIdx == -1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid object format: no null byte")
        }</span>
        
        <span class="cov0" title="0">header := string(fullData[:nullIdx])
        data := fullData[nullIdx+1:]
        
        // Parse object type and size from header
        var objType string
        var size int
        if _, err := fmt.Sscanf(header, "%s %d", &amp;objType, &amp;size); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid object header: %s", header)
        }</span>
        
        <span class="cov0" title="0">if len(data) != size </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("object size mismatch: expected %d, got %d", size, len(data))
        }</span>
        
        // Parse object based on type
        <span class="cov0" title="0">var obj Object
        switch ObjectType(objType) </span>{
        case TypeBlob:<span class="cov0" title="0">
                obj = ParseBlob(id, data)</span>
        case TypeTree:<span class="cov0" title="0">
                obj, err = ParseTree(id, data)</span>
        case TypeCommit:<span class="cov0" title="0">
                obj, err = ParseCommit(id, data)</span>
        case TypeTag:<span class="cov0" title="0">
                obj, err = ParseTag(id, data)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown object type: %s", objType)</span>
        }
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Update cache
        <span class="cov0" title="0">s.mu.Lock()
        s.cache[id] = obj
        s.mu.Unlock()
        
        return obj, nil</span>
}

// HasObject checks if an object exists in storage
func (s *Storage) HasObject(id ObjectID) bool <span class="cov8" title="1">{
        // Check cache
        s.mu.RLock()
        if _, ok := s.cache[id]; ok </span><span class="cov8" title="1">{
                s.mu.RUnlock()
                return true
        }</span>
        <span class="cov8" title="1">s.mu.RUnlock()
        
        // Check loose object
        path := s.objectPath(id)
        if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        
        // TODO: Check packfiles
        <span class="cov8" title="1">return false</span>
}

// objectPath returns the path to a loose object file
func (s *Storage) objectPath(id ObjectID) string <span class="cov8" title="1">{
        hex := id.String()
        return filepath.Join(s.basePath, hex[:2], hex[2:])
}</span>

// compressData compresses data using zlib
func compressData(data []byte) ([]byte, error) <span class="cov8" title="1">{
        var buf bytes.Buffer
        w := zlib.NewWriter(&amp;buf)
        
        if _, err := w.Write(data); err != nil </span><span class="cov0" title="0">{
                w.Close()
                return nil, err
        }</span>
        
        <span class="cov8" title="1">if err := w.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}

// decompressData decompresses data using zlib
func decompressData(compressed []byte) ([]byte, error) <span class="cov0" title="0">{
        r, err := zlib.NewReader(bytes.NewReader(compressed))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer r.Close()
        
        return io.ReadAll(r)</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package objects

import (
        "bufio"
        "bytes"
        "fmt"
        "strings"
)

// Tag represents a git tag object (annotated tag)
type Tag struct {
        id       ObjectID
        object   ObjectID
        typ      ObjectType
        tag      string
        tagger   Signature
        message  string
}

// NewTag creates a new tag object
func NewTag(object ObjectID, typ ObjectType, tag string, tagger Signature, message string) *Tag <span class="cov8" title="1">{
        t := &amp;Tag{
                object:  object,
                typ:     typ,
                tag:     tag,
                tagger:  tagger,
                message: message,
        }
        t.computeID()
        return t
}</span>

// Type returns the object type
func (t *Tag) Type() ObjectType <span class="cov8" title="1">{
        return TypeTag
}</span>

// Size returns the serialized size
func (t *Tag) Size() int64 <span class="cov8" title="1">{
        data, _ := t.Serialize()
        return int64(len(data))
}</span>

// ID returns the object ID
func (t *Tag) ID() ObjectID <span class="cov8" title="1">{
        if t.id.IsZero() </span><span class="cov0" title="0">{
                t.computeID()
        }</span>
        <span class="cov8" title="1">return t.id</span>
}

// Object returns the tagged object ID
func (t *Tag) Object() ObjectID <span class="cov8" title="1">{
        return t.object
}</span>

// ObjectType returns the type of the tagged object
func (t *Tag) ObjectType() ObjectType <span class="cov8" title="1">{
        return t.typ
}</span>

// TagName returns the tag name
func (t *Tag) TagName() string <span class="cov8" title="1">{
        return t.tag
}</span>

// Tagger returns the tagger signature
func (t *Tag) Tagger() Signature <span class="cov8" title="1">{
        return t.tagger
}</span>

// Message returns the tag message
func (t *Tag) Message() string <span class="cov8" title="1">{
        return t.message
}</span>

// Serialize serializes the tag object
func (t *Tag) Serialize() ([]byte, error) <span class="cov8" title="1">{
        var buf bytes.Buffer
        
        // Object
        fmt.Fprintf(&amp;buf, "object %s\n", t.object)
        
        // Type
        fmt.Fprintf(&amp;buf, "type %s\n", t.typ)
        
        // Tag
        fmt.Fprintf(&amp;buf, "tag %s\n", t.tag)
        
        // Tagger
        fmt.Fprintf(&amp;buf, "tagger %s\n", t.tagger)
        
        // Empty line before message
        buf.WriteByte('\n')
        
        // Message
        buf.WriteString(t.message)
        
        return buf.Bytes(), nil
}</span>

// computeID calculates the tag's object ID
func (t *Tag) computeID() <span class="cov8" title="1">{
        data, _ := t.Serialize()
        t.id = ComputeHash(TypeTag, data)
}</span>

// ParseTag parses a tag from raw object data
func ParseTag(id ObjectID, data []byte) (*Tag, error) <span class="cov8" title="1">{
        tag := &amp;Tag{
                id: id,
        }
        
        scanner := bufio.NewScanner(bytes.NewReader(data))
        
        // Parse headers
        inHeaders := true
        var messageLines []string
        
        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                
                if inHeaders </span><span class="cov8" title="1">{
                        if line == "" </span><span class="cov8" title="1">{
                                inHeaders = false
                                continue</span>
                        }
                        
                        <span class="cov8" title="1">parts := strings.SplitN(line, " ", 2)
                        if len(parts) != 2 </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("invalid tag header: %s", line)
                        }</span>
                        
                        <span class="cov8" title="1">key, value := parts[0], parts[1]
                        
                        switch key </span>{
                        case "object":<span class="cov8" title="1">
                                object, err := NewObjectID(value)
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("invalid object ID: %w", err)
                                }</span>
                                <span class="cov8" title="1">tag.object = object</span>
                                
                        case "type":<span class="cov8" title="1">
                                tag.typ = ObjectType(value)
                                if !tag.typ.IsValid() </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("invalid object type: %s", value)
                                }</span>
                                
                        case "tag":<span class="cov8" title="1">
                                tag.tag = value</span>
                                
                        case "tagger":<span class="cov8" title="1">
                                sig, err := parseSignatureLine(value)
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("invalid tagger: %w", err)
                                }</span>
                                <span class="cov8" title="1">tag.tagger = *sig</span>
                                
                        default:<span class="cov8" title="1"></span>
                                // Ignore unknown headers
                        }
                } else<span class="cov8" title="1"> {
                        messageLines = append(messageLines, line)
                }</span>
        }
        
        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing tag: %w", err)
        }</span>
        
        <span class="cov8" title="1">tag.message = strings.Join(messageLines, "\n")
        if len(messageLines) &gt; 0 &amp;&amp; !strings.HasSuffix(tag.message, "\n") </span><span class="cov8" title="1">{
                tag.message += "\n"
        }</span>
        
        <span class="cov8" title="1">return tag, nil</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">package objects

import (
        "bytes"
        "fmt"
        "sort"
        "strconv"
)

// FileMode represents the mode of a file in a tree
type FileMode uint32

const (
        ModeTree    FileMode = 0040000
        ModeBlob    FileMode = 0100644
        ModeExec    FileMode = 0100755
        ModeSymlink FileMode = 0120000
        ModeCommit  FileMode = 0160000 // Submodule
)

// TreeEntry represents an entry in a tree object
type TreeEntry struct {
        Mode FileMode
        Name string
        ID   ObjectID
}

// Tree represents a git tree object (directory listing)
type Tree struct {
        id      ObjectID
        entries []TreeEntry
}

// NewTree creates a new tree object
func NewTree() *Tree <span class="cov8" title="1">{
        return &amp;Tree{
                entries: make([]TreeEntry, 0),
        }
}</span>

// AddEntry adds an entry to the tree
func (t *Tree) AddEntry(mode FileMode, name string, id ObjectID) error <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("entry name cannot be empty")
        }</span>
        
        // Check for duplicate names
        <span class="cov8" title="1">for _, e := range t.entries </span><span class="cov8" title="1">{
                if e.Name == name </span><span class="cov8" title="1">{
                        return fmt.Errorf("duplicate entry name: %s", name)
                }</span>
        }
        
        <span class="cov8" title="1">t.entries = append(t.entries, TreeEntry{
                Mode: mode,
                Name: name,
                ID:   id,
        })
        
        // Recompute hash after modification
        t.computeID()
        return nil</span>
}

// Entries returns all tree entries
func (t *Tree) Entries() []TreeEntry <span class="cov8" title="1">{
        return t.entries
}</span>

// Type returns the object type
func (t *Tree) Type() ObjectType <span class="cov8" title="1">{
        return TypeTree
}</span>

// Size returns the serialized size
func (t *Tree) Size() int64 <span class="cov8" title="1">{
        data, _ := t.Serialize()
        return int64(len(data))
}</span>

// ID returns the object ID
func (t *Tree) ID() ObjectID <span class="cov8" title="1">{
        if t.id.IsZero() </span><span class="cov8" title="1">{
                t.computeID()
        }</span>
        <span class="cov8" title="1">return t.id</span>
}

// Serialize serializes the tree object
func (t *Tree) Serialize() ([]byte, error) <span class="cov8" title="1">{
        // Sort entries by name for consistent hashing
        sorted := make([]TreeEntry, len(t.entries))
        copy(sorted, t.entries)
        sort.Slice(sorted, func(i, j int) bool </span><span class="cov8" title="1">{
                return sorted[i].Name &lt; sorted[j].Name
        }</span>)
        
        <span class="cov8" title="1">var buf bytes.Buffer
        for _, entry := range sorted </span><span class="cov8" title="1">{
                // Format: &lt;mode&gt; &lt;name&gt;\0&lt;20-byte SHA-1&gt;
                fmt.Fprintf(&amp;buf, "%o %s\x00", entry.Mode, entry.Name)
                buf.Write(entry.ID[:])
        }</span>
        
        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}

// computeID calculates the tree's object ID
func (t *Tree) computeID() <span class="cov8" title="1">{
        data, _ := t.Serialize()
        t.id = ComputeHash(TypeTree, data)
}</span>

// ParseTree parses a tree from raw object data
func ParseTree(id ObjectID, data []byte) (*Tree, error) <span class="cov8" title="1">{
        tree := &amp;Tree{
                id:      id,
                entries: make([]TreeEntry, 0),
        }
        
        for len(data) &gt; 0 </span><span class="cov8" title="1">{
                // Find the space separating mode and name
                spaceIdx := bytes.IndexByte(data, ' ')
                if spaceIdx == -1 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid tree format: no space found")
                }</span>
                
                // Parse mode
                <span class="cov8" title="1">modeStr := string(data[:spaceIdx])
                mode, err := strconv.ParseUint(modeStr, 8, 32)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid file mode: %s", modeStr)
                }</span>
                
                <span class="cov8" title="1">data = data[spaceIdx+1:]
                
                // Find the null byte separating name and hash
                nullIdx := bytes.IndexByte(data, 0)
                if nullIdx == -1 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid tree format: no null byte found")
                }</span>
                
                <span class="cov8" title="1">name := string(data[:nullIdx])
                data = data[nullIdx+1:]
                
                // Read the 20-byte SHA-1 hash
                if len(data) &lt; 20 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid tree format: insufficient data for hash")
                }</span>
                
                <span class="cov8" title="1">var objID ObjectID
                copy(objID[:], data[:20])
                data = data[20:]
                
                tree.entries = append(tree.entries, TreeEntry{
                        Mode: FileMode(mode),
                        Name: name,
                        ID:   objID,
                })</span>
        }
        
        <span class="cov8" title="1">return tree, nil</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package objects

import (
        "fmt"
        "time"
)

// ObjectType represents the type of a git object
type ObjectType string

const (
        TypeBlob   ObjectType = "blob"
        TypeTree   ObjectType = "tree"
        TypeCommit ObjectType = "commit"
        TypeTag    ObjectType = "tag"
)

// IsValid returns true if the object type is valid
func (t ObjectType) IsValid() bool <span class="cov8" title="1">{
        switch t </span>{
        case TypeBlob, TypeTree, TypeCommit, TypeTag:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// Object is the base interface for all git objects
type Object interface {
        Type() ObjectType
        Size() int64
        ID() ObjectID
        Serialize() ([]byte, error)
}

// Signature represents author/committer information
type Signature struct {
        Name  string
        Email string
        When  time.Time
}

// String returns the signature in git format
func (s Signature) String() string <span class="cov8" title="1">{
        timestamp := s.When.Unix()
        tz := s.When.Format("-0700")
        return fmt.Sprintf("%s &lt;%s&gt; %d %s", s.Name, s.Email, timestamp, tz)
}</span>

// ParseSignature parses a signature from git format
func ParseSignature(data []byte) (*Signature, error) <span class="cov8" title="1">{
        // Implementation will be added when needed
        return nil, fmt.Errorf("ParseSignature not yet implemented")
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
